---
tags:
---

{{{ ###Overview
## Overview
	> Microsoft Engineering Common Criteria: The standard microsoft stuff is built on
		- PowerShell's got hooks for them all.


	> Module: a grouping of functions and code around a central theme or object to manage
		$ get-module
	> Provider: NET programs that provide access to specialized data stores for easier viewing and management.
		- A dataset/language translater
		$ get-psproviders
	> Cmdlet: a small script that is intended to perform a single specific function such as coping files and changing directories.
		$ get-command

## Modules

	- 2.0 and 3.0 there are 11 Core Modules
	- 4.0 there are 12 Core Modules
	- 5.0 there are 18 Core Modules
	> Microsoft.PowerShell.Core Module: The Core module contains cmdlets and providers that manage the basic features of Windows PowerShell.

	> Microsoft.PowerShell.Diagnostics Module: The Diagnostics module contains cmdlets that manage event logs, performance counters, and Event Tracing for Windows (ETW).

	> Microsoft.PowerShell.Host Module: The Host module contains cmdlets that manage data from host programs.

	> Microsoft.PowerShell.Management Module: The Management module contains cmdlets that help you manage Windows in Windows PowerShell.

	> Microsoft.PowerShell.Security Module: The Security module contains the Certificate Provider and cmdlets that manage the security features of Windows PowerShell, including execution policies.

	> Microsoft.PowerShell.Utility Module: The Utility module contains cmdlets that manage the basic features of Windows PowerShell.

	> Microsoft.WSMan.Management Module: The WSMan Management module contains the WSMan Provider and cmdlets that manage Web Services for Management (WS-Management) and Windows Remote Management (WinRM).

	> ISE Module: The Integrated Scripting Environment (ISE) module contains cmdlets that add features to Windows PowerShell Integrated Scripting Environment (ISE).

	> PSScheduledJob Module: The PSScheduledJob module contains cmdlets and providers that manage scheduled jobs in Windows PowerShell.

	> PSWorkflow Module: The PSWorkflow module includes cmdlets that support the Windows PowerShell Workflow feature.

	> PSWorkflowUtility Module: The PSWorkflowUtility module includes commands that manage the Windows PowerShell Workflow feature.

	> PSDesiredStateConfiguration Module: The PSDesiredStateConfiguration module includes the cmdlets that manage Windows PowerShell Desired State Configuration (DSC). DSC is a management platform in Windows PowerShell that enables deployment and management of configuration data for software services, and management of the environment in which these services run.

	- Module Locations
		- Users Home Dir
			- First Placed Checked
			- Does not exist by default
		- WIndows Powershell Program Files
			- Standard Location: C:\Program Files\WindowsPowerShell
		- Powershell home Directory
			- Always exists
			- Used when users module dir does not exist
			
	- States 
		- Loaded
		- Unloaded
		
## Providers

	- 6 providers in Version 4.0

	> Alias (Drive={Alias}): Alias provides simplified access to all aliases defined in Windows PowerShell. Use the Set-Location cmdlet and specify the Alias:\ drive to work with the aliases on your computer. After that, you can use the same cmdlets you would use to work with the file system.
		
	> Environment (Drive={Env}): Environment is used to provide access to the system environment variables. If you enter set within a CMD shell, you will obtain a listing of all the environment variables defined on the system. You can run the old-fashioned command prompt inside Windows PowerShell by typing CMD.

	> FileSystem (Drive={C, D}): FileSystem provides access to the file system, making it the easiest to comprehend. When PowerShell is started, it automatically opens on the user documents folder where you can:

		- Create both directories and files
		- Retrieve properties of files and directories
		- Delete files and directories
		- Open files and append or overwrite data to the files through inline code or by using the pipelining feature

	> Function (Drive={Function}): Function provides access to the functions defined in PowerShell through a file system-based model. Through the function provider, you can:

		- Obtain a listing of all the functions on your system
		- Add, modify, and delete functions 

	> Registry (Drive={HKLM, HKCU}): Registry supplies access to the registry in the same manner that the filesystem provider permits access to a local disk drive. The equivalent cmdlets used to access the file system: New-Item, Set-Item, Get-ChildItem, Remove-Item, etc. also work with the registry.

		- The inclusion of remote computing with Windows PowerShell 2.0 made it possible to create remote registry changes as easily as changing the local registry. The registry provider supplied with PowerShell 3.0 improved with the introduction of transactions; whereas, there have been no major increases in functionality with the registry provider in PowerShell 4.0 and PowerShell 5.0.

	> Variable (Drive={Variable}): Variable provides access to the variables that are defined within PowerShell. You can obtain a listing of the cmdlets designed to work specifically with variables by using the Get-Help cmdlet and specifying *variable as a value for the -Name parameter. These variables include:

		- User-defined variables, such as $broncs
		- System-defined variables, such as $host	

		
}}} ###

{{{ ### Scripts

## HashTables (
	> HashTable: Calculated Property

	$ Get-Service | Sort-Object -Property @{Expression="Status";Descending=$true}, @{Expression="DisplayName";Descending=$false}

## Anatomy

	> Variables: $
	> Strings: '' = non-expanded | "" = expanded
	> Contents of file:	${C:\yeet.txt}
	> $args: all args passed via commandline
	> $_: Current Object in pipeline

## Execution Policy

	- Levels

		1. Restricted - Does not load configuration files such as the Windows PowerShell profile or run other scripts. Restricted is the default setting.
		2. AllSigned - Requires that all scripts and configuration files be signed by a trusted publisher, including scripts that you write on the local computer.
		3. RemoteSigned - Requires that all scripts and configuration files downloaded from the Internet be signed by a trusted publisher.
		4. Unrestricted - Loads all configuration files and runs all scripts. If you run an unsigned script that was downloaded from the Internet, you are prompted for permission before it runs.
		5. Bypass - Blocks nothing and issues no warnings or prompts.
		6. Undefined - Removes the currently assigned execution policy from the current scope. This parameter will not remove an execution policy that is set in a Group Policy scope.

	- Scopes

		1. Process - The execution policy affects only the current Windows PowerShell process.
		2. CurrentUser - The execution policy affects only the current user.
		3. LocalMachine - The execution policy affects all users of the computer. Setting the Local-Machine execution policy requires administrator rights on the local computer.

	
	- Get execution policy for all scopes 
		 $ Get-ExecutionPolicy -List




}}} ###

{{{ ###ISE

	- Windows 7=first release
	- Paste into reglar console:
		- Alt+Space+E+P

}}} ###

{{{ ###PowerShell Remoting

## Fun Facts
	- Need at least powershell 2.0 and option enabled
	- There is a reg key you can change so that you get a password prompt instead of a pop-up box
	- Query Communication Protocol:
		- Powershell gte 3 = WSMan
		- PowerShell lte 2 = DCOM (Distributed Component Object Module)
		

}}} ###

{{{ ###Logging

	- 2.0 Logging
		- PowerShell Executed
		- start and end times of sessions
		- whether the session executed locally or remotely (ConsoleHost or ServerRemoteHost).
	- 5.0 Logging 
		- Executed PowerShell commands and scripts
		- Deobfuscated code
		- Output
		- Transcripts of historic activity
		
	- Updating Logging;
		- Windows 7/8.1/Server 2008 R2/Server 2012 R2
			- Requirements
				- .NET 4.5
				- Windows Management Framework (WMF) 4.0
				- The appropriate WMF 4.0 update
					- 8.1/2012 R2: KB300850
					- 2012: KB3119938
					- 7/2008 R2 SP1: KB3109118
					
	- Logging is configured via Group Policy:
		- Location:
			-  Administrative Templates → Windows Components → Windows PowerShell
			
	- Logging Types:
		- Module Logging: details as PowerShell executes
			- Records:
				- Variable Initialization
				- Command Invocation
				- recors portions of scripts
				- some deobfuscated code 
				- some data formtted output
			- Fun Facts;
				- Available since 3.0
				- EID 4103 and 800
			- To enable Module Logging;
				- In the Windows PowerShell GPO settings, set Turn on Module Logging to enabled.
				- In the Options pane, click the button to show Module Name.
				- In the Module Names window, enter * to record all modules.
				 	- Optional: To log only specific modules, specify them here. (Note: this is not recommended.)
				- Click OK in the Module Names window.
				- Click OK in the Module Logging window.
				- OR -
				- Fixup these keys:
					- HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\ModuleLogging EnableModuleLogging = 1
					- HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\ModuleLogging\ModuleNames * = *
		- Script block Logging:  records deobfuscated code as it is executed
			- Will not record output 
			- EID 4104
			- *In 5.0* SuS content will be logged even if it is not enabled (warning level)
			- Less events than module loggng (good for SIEM)
			- Start = EID 4105 
			- Stop 	= EID 4106 (start/stop logging is generally too much data)
			- To enable:
				- In Windows PowerShell GPO settings, set "Turn on PowerShell Script Block Logging" to enabled
				- OR -
				- HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging EnableScriptBlockLogging = 1 
		- Transcription: input and output, exactly as it appears in the session.
			- Contains:
				- input and output 
				- timestamp
				- metadata (name, size, mod date, create date)
				- Only terminal output (not written to filesystem files)
			- Fun facts:
				- named PowerShell_transcript<filename>:
				- default file location is username\documents\ (best if logged remotely)
				- easy to read (and grepable!)
			- To enable:
				- In the Windows PowerShell GPO settings, set "Turn on PowerShell Transcription" to enabled.
				- Check the "Include invocation headers" box, in order to record a timestamp for each command executed.
				- Optionally, set a centralized transcript output directory.
				- OR -
					- HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\Transcription EnableTranscription = 1
					- HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\Transcription EnableInvocationHeader = 1
					- HKLM\SOFTWARE\Wow6432Node\Policies\Microsoft\Windows\PowerShell\Transcription OutputDirectory ="" (Enter path. Empty = default)	
	
	- Event logs locations
		- Appliction Logs
			- Windows PowerShell.evtx
			- Microsoft-Windows-PowerShell/Operational.evtx
			- Microsoft-Windows-WinRM/Operational.evtx
		- Analytic Logs
			- Microsoft-Windows-PowerShell/Analytic.evtl
			- Microsoft-Windows-WinRM/Analytic.etl	
	
	- Best Practice:
		- BEST:
			- Module + Script Block + Transcription 
			- Event log should be increaded to 1GB 
		- If storage is an issue:
			- Script Block + Transcription
		- At a minimum:
			- Script Block
	
	- WinRM Logging: Inbound and outbount winrm conecitons
		- Logs:
			- Source
			- Destination
			- Username
		- Best Practice:
			- Should be able to store at least 1 year of data
			>: at a minimum, aggregating and monitoring suspicious script block logging events, EID 4104 with level "warning", in a SIEM or other log monitoring tool.
	
## Examples
	{{{ #Example: PowerShell Remoting or Local Script Execution
Windows PowerShell.evtx
	Event ID 400 and 403 record the start & stop times of a PowerShell session
	EID 400: Engine state is changed from None to Available.r
	HostName=ConsoleHost
	EID 403: Engine state is changed from Available to Stopped.
	HostName=ConsoleHost

Microsoft-Windows-PowerShell/Operational.evtx
	(PowerShell 3.0 and greater)
	Event ID 40961 records the start time of PowerShell session
	EID 40961: PowerShell console is starting up
	Event ID 4100 is an error message that provides path to PowerShell script
	EID 4100: Error Message = File C:\temp\crazy.ps1 cannot be loaded because running scripts is disabled on this system

Microsoft-Windows-PowerShell/Analytic.etl
	(Log disabled by default. Events exclusive to PowerShell 3.0 or greater)
	The Event ID 7937 records executed cmdlets, scripts, or commands (no arguments)
	EID 7937: Command crazy.ps1 is Started.
	EID 7937: Command Write-Output is Started.
	EID 7937: Command imhere.exe is Started
	
	}}} #
	{{{ #Example: PowerShell Remoting 
Windows PowerShell.evtx
	Event ID 6 records the start of a remoting session (client host)
	EID 6: Creating WSMan Session. The connection string is: 192.168.1.10/wsman? PSVersion=3.0
	Event ID 400 and 403 record the start & stop of a PowerShell remoting session
	EID 400: Engine state is changed from None to Available. HostName= ServerRemoteHost
	EID 403: Engine state is changed from Available to Stopped. HostName= ServerRemoteHost		
		
		
	}}} #
	{{{ #Example: PowerShell Remoting

Microsoft-Windows-WinRM/Operational.evtx
	Event ID 169 records who connected via remoting
	EID 169: User CORP\VonM authenticated successfully using NTLM
	Event ID 81 and 134 record the timeframe of the remoting activity
	EID 81: Processing client request for operation CreateShell
	EID 134: Sending response for operation DeleteShell

Microsoft-Windows-PowerShell/Analytic.etl
	The Event ID 32850 records who connected via remoting
	EID 32850: Request 7775818. Creating a server remote session. UserName: CORP\JohnE
	The Event ID 32867 and 32868 records the encoded contents of remoting I/O
	EID 32867: Received remoting fragment […] Payload Length: 777 Payload Data: 0x020000000200010064D64FA51E7C68428483DB[…]
	EID 32868: Sent remoting fragment […]Payload Length: 180 Payload Data: 0xEFBBBF3C4F626A2052657794643D2230232E3[…]		
		
		
	}}} #
		
}}} ###

{{{ ###WMI

## WMI Model

	- Sections:
		- Resources
			- File system
			- Networked components
			- Event logs
			- Files
			- Folders
			- Disks
			- AD DS
		- Infrastructure
			- WMI Service
			- WMI repository
			- WMI providers :Means for WMI to gather information
		- Consumers ( a way to process data from wmi )
			- A Windows PowerShell cmdlet
			- A Microsoft Visual Basic Scripting Edition (VBScript) script
			- An enterprise management software package
			- Some other tool or utility that executes WMI queries
			
	- CIM
		- CIM cmdlets support multiple ways of exploring WMI
		- To find CIM classes
			$ get-CIMCLASS
		- Default WMI namespace
			- on all operating systems after Windows NT 4.0 is Root/Cimv2. All CIM cmdlets default to Root/Cimv2


}}} ###







{{{ #Powershell
	- Get Loaded Modules
		$ get-module
	- Get Loaded and Unloaded Modules 
		$ get-module -ListAvailable
	- Get Powershell Version 
		$ get-host 
	- Set Alias
		$ set-alias -name gh -value Get-ChildItem
	- Test network connection (ping)
		$ test-connection 1.1.1.1
	- Enable and Configure WinRm
		$ winrm quickconfig -q		#You may need to setup "Trusted Hosts"
	- Run remote Command
		$ get-hotfix -ComputerName win7
		$ Get-Hotfix -ComputerName win10 -Credential barney
	- Create a credential variable
		$c = get-credential -Computername win10 
	- Use credential Variable
		$ get-hotfix -computername win10 -credential $c | where {$_.Description -match "Security"}
	- Invoke Command
		$ $session7 = New-PSSession -computername win7 -credential win7\administrator
		$ invoke-command $session7 -scriptblock { get-process }
	- Enter Remote PSSession
		$ $session7 = New-PSSession -computername win7 -credential win7\administrator
		$ Enter-PSSession -session $session7
		$ Exit-PSSession
	- Remove pssession
		$ Get-PSSession
		$ Remove-PSSession -id 32
	- Create cimsession (WSMAN (Powershell 3 and newer))
		$ $c = New-CimSession -ComputerName win10 -Credential fred
		$ $c | Get-CimInstance -ClassName Win32_Service -filter "State like 'Running'"
	- Create CIMSession (DCOM (Powershell 2 and older))
		$ $g = get-credential
		$ $so = new-cimsessionoption -protocol DCOM
		$ $d = new-cimsession -computername win7 -credential $g -SessionOption $so
		$ get-cimsession		
		$ get-cimsession -id 6 | get-ciminstance win32_service | where {$_.state -like "Running"} | select name
		
	- Enable logging for all modules 
		$ get-module | ForEach { $_.LogPipelineExecutionDetails = $True }
	- Get the most recent PowerShell Event Log 
		$ Get-WinEvent -FilterHashtable @{LogName='Windows PowerShell';Id ='800'} -MaxEvents 1 | Select -Expand Message
	- List running services 
		$ gwmi win32_service | where {$_.state -match "Running"} | select name
		$ gwmi Win32_Service -filter "State like 'Running'" -Credential fred -Computer win7
	- Use WMI SQL (WSQL)
		$ gwmi -query "select * from win32_service where state = 'Running'" | select name
	- Get hardware serial number
		$ Get-WmiObject -query "select * from Win32_SystemEnclosure" -ComputerName win7 -Credential $c | select SerialNumber
		$ Get-WMIObject -query "select * from win32_bios" -computername win7 -credential $c | select serialnumber
		$ gwmi -query "Select * from win32_bios" | finstr "^SerialNumber.*"
	- Remove an application
		$ (Get-WmiObject Win32_Product -computername win7 -credential $c -filter "Name like '%Ask'").Uninstall()
		$ Get-WmiObject Win32_Product -computername -credential $c -Filter "Name like '%Ask'"

	- Search CIMClasses
		$ Get-CimClass | Where {$_.CimClassName -match 'User'}
	- Look through namespaces
		$ get-ciminstance -namespace ^TAB_Through^
		
}}} #	
		
{{{ #Nonsense
$ get-alias
$ dir HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall | Get-ItemProperty
$ (get-alias).count
$ gci C:\ | select name, length, LastAccessTime | Format-Table -AutoSize
$ get-command 
$ gcm get-alias | format-list *
$ (gcm get-alias).definition
$ gcm -verb g*
$ gcm -noun a*
$ Get-ChildItem *.zip | Sort-Object -Property @{Expression={$_.LastWriteTime - $_.CreationTime}; Ascending=$false} | Format-Table LastWriteTime, CreationTime
}}} #		

