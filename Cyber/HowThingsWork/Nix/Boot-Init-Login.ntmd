{{{ ###Boot Overview
## Portions of Boot Process
	1. Power On and Firmware Initalization
		1. System is powered on 
		2. BIOS or UEFI is loaded by the processor
			- Usually stored on ROM chip or flash memory
		3. POST
		4. Available Boot sectors on any bootable device are discovered
		5. BIOS or UEFI Loades and executes the bootloader program ( From MBR or GPT )
	2. Bootloader (Often GRUB)
		- Usually a "Chained" | "multi-staged" Process 
		1. Bootloader presents boot options (and options to send to the kernel)
		2. Boot Option is selected
		4. Bootloader loads the kernel image into memory and initializes it 
		5. Booloader mounts ramdisk (initrd) image which serves as a tmporary root filesystem 
	3. Kernel Initalization
		1. Memory managment established
		1. processor configuration checked
		2. initalizes kernel threads (done when kernel image file and inital ramdisk are loaded into memory)
			- creates temporary filesystem (either initrd or initramfs)
				> initrd: RAM-Based block device called a ramdev. Contains an image of a filesystem. (needs driver) (old)
				> initramfs: compressed archive file and is uncompressed then mounted directly into the kernel as a tmpfs filesystem. (Does not need driver) (new)
			- Contains some neccessary executables and drivers	
			- Must contain a minimal set of directories and executables to mount the root filesystem.
	4. User Space Initalization
		1. First user space process is created
		1.5 Begin Post-Kernel Boot Process 
		2. First user space process...
			1. sets up os funcitons
				- console interfaces
				- Default sig handlers for processes
				- Application Services
				- Daemons
		3. Login Shell becomes available

}}} ###		
{{{ ###Boot Fun Facts 		
## Grub Stages 
	1. executes a small program that is primarily responsible for loading the Stage 1.5 bootloader
	1.5. provides filesystem support
		- which allows the bootloader to read from the boot device by pathname, instead of by physical address.
		- Loads stage 2.
	2.  locates and loads the kernel into RAM and hand off control to the kernel. 
		- contains the bulk of the bootloader code, to include that which allows users to select a kernel and kernel boot options. 

## Old Solaris Bootloader Stages
	0. mboot is loaded into the bootloader 
	1. > mboot: (Master Boot) loads and runs pboot
	2. > pboot: (Primary Boot) invokes bootblk 
	3. > bootblk: Provides user with kernel options and boot options 

## Kernel initialization
	- Typical tempfile locations
		- /kernel or /platform 	| Solaris 
		- /boot/vmlinuz* 		| Linux

### Kernel Threads
	> Kernel threads: Processes that take place entirley in kernel memory
	> sched: (scheduler) (Solaris 10) (Swapper) (PID 0)shares processor among all processes
		- Shows on solaris as PID0 and PPID to kernel processes 
		- Does not show on Linux but is referenced by init
	> slice: quantum time allocated to a process for cpu access

}}} ###
{{{ ###Good to know Commands		
	> chkconfig: used to list all available services and view or update their run level settings
	$ chkconfig --list [name]
	$ chkconfig --add name
	$ chkconfig --del name
	$ chkconfig --override name
	$ chkconfig [--level levels] name 
	$ chkconfig [--level levels] name
> init: the last step of the kernel boot sequence.
	- /etc/inittab is the contorl file.
> invoke-rc.d: generic interface to execute System V style init script  /etc/init.d/name actions,  obeying  runlevel  constraints  as  well as any local policies
> runlevel: used to find the current and previous runlevels
> service: used to run a System V init script
> svcadm:  used to enable, disable, restart, or refresh services
> svc.startd:  master restarter daemon for Service Management Facility (SMF)
> svcs:  displays information about the state of your services (SMF)
> systemctl: responsible for examining and controlling the systemd system and service manager
> initctl: allows a system administrator to communicate and interact with the Upstart init(8) daemon
> update-rc.d: updates the System V style init script links /etc/rcrunlevel.d/NNname whose target is the script /etc/init.d/name
> who: displays a list of users who are currently logged into the computer
        
}}} ###
{{{ ###Init Identification and Tables
	{{{ #man init Examples
		## System V 
		INIT(8) Linux System Administrator’s Manual INIT(8)

		NAME
		init, telinit – process control initialization

		## System D
		SYSTEMD(1) systemd SYSTEMD(1)

		NAME
		systemd, init – systemd system and service manager

		## Upstart 
		init(8) System Manager’s Manual init(8)

		NAME
		init – Upstart process management daemon

		## SMF
		System Administration Commands init(1M)

		NAME
		init, telinit – process control initilization

	}}} #
	{{{ #init processes
		- SMF
			- PID 1: /sbin/init
		- SysD
			- PID 1: /usr/lib/systemd/systemd or /sbin/init (actually a Symlink to /usr/lib/systemd/systemd)
		- SysV
			- PID 1: init 
		- Upstart 

	}}} #
	{{{ #Init Systems To OS Table

		Init Method	| SysV Compatible	| OS
		---			| ---				| ---
		SysV		| Yes				| RHEL/CentOS 5 (and earlier)
		SysV		| Yes				| Debian 7 (and earlier)
		SysV		| Yes				| Solaris 9 (and earlier)
		SMF			| Yes				| Solaris 10
		Upstart		| Yes				| 
		Systemd		| Yes				| 

	}}} #
	{{{ #Runlevels Table
		Runlevel	| Purpose (Linux)				
		---			| ---							
		0			| System Shutdown				
		1 (S)		| Single-User Mode				
		2			| Multi-User Mode Non-Networked	
		3			| Multi-User Mode Networked		
		4			| Extra/Unused					
		5			| GUI Mode 						
		6			| Reboot						

			- odd runlevel behavior 
				- Solaris 
					- runlevel 3 will launch all of the programs associated with runlevel 2, followed by those for runlevel 3
					- runlevel 4 is even configured to exist
					- runlevel 5 is also for shutdown 
				- Debian 
					- runlevel 2-5 are configured the same by default 
			- when runlevel changes 
				- init:
					- Re-reads its config file 
					- Terminates certain processes 
					- Launches appropriate programs for the new runlevel 
					- new init process terminates when new runlevel is established.
					
	}}} #
	{{{ #Unit Info 
		> Load: reflects whether the unit definition was properly loaded
			- Get all unit files and statuses
				$ systemctl list-unit-files 
				$ systemctl list-units --all
			- Load States 
				> Enabled: Will be started at boot time. (enabled through symlink in a *.wants/ directory)
				> Disabled: Will not be started at boot time. (Can be manually started)(Symlink within /etc/systemd/system does not exist)
				> Static: Cannot be enabled, but may be started by an enabled unit automatically. Has no previsions to enable it in the intall section.
		> Active: High level unit activation state
			- Get all active units (that systemd knows about)(attempted to load)
				$ systemctl list-units 
			- Get all AVAILABLE unit files (that systemd knows about)
				$ systemctl list-unit-files 
			- Active Statuses
				> active: Unit is running or has ran 
				> inactive: Not active or running (Potentially failed to start)
		> SUB: Low level unit activation state 
			- Get subactivation states of systemd units 
				$ systemctl list-units 
			- SUB Statuses 
				> running: Running with one or more continuing processes
				> exited: Successfully executed a process then exited.  
				> waiting: Running, But waiting for an event to occur.
				> dead: Not running. (Potentially failed to start)
				> plugged: Device is already working.

	}}} #

}}} ###
{{{ ###Init Systems (Class Notes)(Delete me??)
{{{ #SMF
Feature					| SMF
---						| ---
Boot Config				| Database
Startup Script Location	| /lib/svc/method
Respawning				| svc.startd 
Default Milestone		| 

Milestone			| Runlevel
---					| ---
none				| N/A
single-user			| S
multi-user 			| 2
Multi-User-server 	| 3
all					| 3

	- milestones
		1. Devices
		2. Sysconfig
		3. Network
		4. Name-Services 
		5. Single-User 
		6. Multi-User
		7. Multi-User Server 

	- Process
		1. svc.startd starts 
			- reads /etc/inittab
		1. svc.configd starts 
			- manages access to SMF repository (/etc/svc/repository.db)
			
	- Fun Facts 
		- inetd also controls some of the services 
	
}}} #
{{{ #System D
	1. pid 1 is /usr/lib/systemd/systemd or /sbin/init (actually a Slink to /usr/lib/systemd/systemd)
	2. Unit files are read from:
		- /etc/systemd/system <Takes presidence if file with same name is in both locations 
		- /usr/lib/systemd/system 
		
	- Types of unit files:
		- Socket	(.socket) encapsulates local IPC or network sockets in the system 
		- Service 	(.service) (IE: sshd, httpd) 
		- Target 	(.target) Groups units together during boot-up
	
	- Targets
		- runlevels = targets
		- default target = /etc/systemd/system/defualt.target (symbolic link to /usr/lib/systemd/system/X.target)
			- /etc/inittab is ignored
		- /etc/systemd/system/
		- target "levels" order 
			- local-fs-pre.target 
			- local-fs.target
			- sysinit.target
			- basic.target		
			- multi-user.target	(similar to runlevel 3)
			- graphical.target  (similar to runlevel 5)
			
			Runlevel| Target 
			---		| ---
			0		| poweroff.target 
			1		| rescure.target 
			2		| multi-user.target
			3		| multi-user.target
			4		| multi-user.target
			5		| graphical.target
			6		| reboot.target 

	- Unit states 
		> Load: reflects whether the unit definition was properly loaded
			- Get all unit files and statuses
				$ systemctl list-unit-files 
				$ systemctl list-units --all
			- Load States 
				> Enabled: Will be started at boot time. (enabled through symlink in a *.wants/ directory)
				> Disabled: Will not be started at boot time. (Can be manually started)(Symlink within /etc/systemd/system does not exist)
				> Static: Cannot be enabled, but may be started by an enabled unit automatically. Has no previsions to enable it in the intall section.
		> Active: High level unit activation state
			- Get all active units (that systemd knows about)(attempted to load)
				$ systemctl list-units 
			- Get all AVAILABLE unit files (that systemd knows about)
				$ systemctl list-unit-files 
			- Active Statuses
				> active: Unit is running or has ran 
				> inactive: Not active or running (Potentially failed to start)
		> SUB: Low level unit activation state 
			- Get subactivation states of systemd units 
				$ systemctl list-units 
			- SUB Statuses 
				> running: Running with one or more continuing processes
				> exited: Successfully executed a process then exited.  
				> waiting: Running, But waiting for an event to occur.
				> dead: Not running. (Potentially failed to start)
				> plugged: Device is already working.
	
	- Enabling a service (to start on boot)
		$ systemctl enable sshd 
		1. Symbolic link is created in /etc/systems/system/TARGET_NAME.wants/SERVICE_UNIT to /usr/lib/systemd/system/SERVICE_UNIT.service 
	
	- Adding a Service 
		1. add a unit file to /usr/lib/systemd/system 
			- bare minimum 
				```O
				[Service]
				ExecStart=/path/to/file 
				```C
			- To make service enableable (when enabled this will create a symlink to /etc/systemd/system/multi-user.target.wants/)
				```O
				[Install]
				WantedBy=multi-user.target
				```C
		2. Reload Daemons 
			$ systemctl daemon-reload
		3. Start service
			$ systemctl start my.service 
		4. View modified unit files 
			$ systemd-delta 
			
	- Why a unit file wouldn't have an install section (meaning it is not meant to be enabled)
		- A unit may be statically enabled by being symlinked to another unit's .wants/ or .requires/ directory.
		- The purpose of the unit may be to act as a helper for some other unit which has a requirement dependency on it.
		- A unit may be started when needed via some form of trigger (socket, path, timer, D-Bus, udev, scripted systemctl call, etc.). 
		
	- Dependencies
		- Get Dependencies 
			$ systemctl list-dependencies sshd --no-pager
		- Get Depends Ons (Things that depend on the service to start 
			$ systemctl list-dependencies sshd --reverse 
		- Startup order Directives 
			> Requires=: Units that must be started before the unit starts itself. (The units dependencies)
			> After=: This unit Must be started after the units listed in this directive.
			> Conflicts=: This unit cannot be started if any of the units listed in this directive have been started. 
			> Wants=: Lists all other units that will be started if this unit is started.
				- /etc/systemd/system/NAME.target.wants 			
	- Get default target
		$ systemctl get-default 
		$ vim /etc/systemd/system/defualt.target #(usually a symbolic link to /usr/lib/systemd/system/X.target) #/etc/inittab is ignored
	
}}} #
{{{ #System V
	- Serial initialization method which starts processes and services one after the other
	- First userspace process with PID 1
	
	> /etc/rc.d: contains:
		- startup scripts
		- Local Customization
		- Userspace services 
		- Operating system services
			- IpTables Firewall
			- CUPS printer server 
		- Application Services
			- web server 
			- Mail server 

	> /etc/rc.d/rc.sysinit: Contains configuration Items
		- Timezone
		- hostname
		- Mounts filesystems
		- Other similar tasks
	
	> /etc/rc.d/rc.local: Configures services to run after all services are up.
		- Typically from System specifig configs 
			- VPN Tunnels
			- Custom scripts 
		
	> /etc/rc.d/init.d: Contains startup scripts used to control services 
		- Each script must implement START and STOP routines (many also have status, and restart)
		
	> /etc/rc.d/rc or /etc/rc.d/rc0-6.d: define which services should be running in the associated runlevel.
		- usually symbolic links to scripts in the /etc/rc.d/init.d directory.
		- start scripts will not run until all kill scripts have been executed.
		- If priority is the same, they will execute in alphabetical order.
		
	> /etc/inittab: Config file	
		- Fields
			1. ID: uniquely identify the line within the internal processing of init's process list.
				- id = initdefault
				- si = system initialization
			2. runlevel: determines which set of scripts to run based upon a runlevel.
				- default runlevel is read from inittab 
				- if blank will run on all runlevels 
			3. action: tells init how it should interpret the information on the line 
			4. program and options: contains the path and name of the executable that should be run, along with all the command line options that should be used.
		- keywords
			> wait: tells init to wait for the program to finish executing before going to next line 
			> respawn: tells init to continually monitor the process, and respawn a new copy if the program ever terminates.
			> initdefault:
			> sysinit:
				- sysinit line will be started and finished executing before moving to next line.
				- sysinit lines ONLY run at boot. (not at runlevel changes)
				- first script executed is the rc.sysinit script
				
}}} #
{{{ #Upstart 
	1. /sbin/init starts with pid 1
	2. init reads .conf files from /etc/init
		- (and subdirs if they exist)
		- each .conf file defines a service for the system
	2.5. One of the .conf files is used to kick off /etc/rc.d/rcX.d/ scripts (for starting and killing)

}}} #
		
}}} ###

{{{ ###System V 
	{{{ #Important Dirs 
		> init.d: Hosts Startup Scripts 
			- Locations:[debian /etc/init.d] [rhel /etc/rc.d/init.d]
		> rc[1-6].d: Hosts Links to scripts to run at runlevel changes (S and K with order number)
			- Locations:[debian /etc/rc[1-6].d][RHEL /etc/rc.d/rc[1-6].d]
		
	}}} #
	{{{ #Important Files
		> inittab: Master Config File
			- Locations:[debian /etc/inittab][RHEL /etc/inittab]
		> rc: Takes argument [1-6] and executes links in rc[1-6].d dir
			- Locations:[debian /etc/init.d/rc][RHEL /etc/rc.d/rc]
		> rc.local: A is a script to kickoff B (usually for local services like VPN's)(runs after all others are up)
			- Locations:[debian /etc/init.d/rc.local, /etc/rc.local ][RHEL /etc/rc.d/rc.local /etc/rc.local]
		> rc.sysinit: Contains local Configs (not mandatory)(Runs before services are up)
			- Locations:[debian N/A][RHEL /etc/rc.d/rc.sysinit]
	}}} #
	{{{ #Process
		1. Inittab is read and "executed" from the top down
			- This means that the default RL is read from here,
			- sysinit is ran (to get to a single user mode)
			- rc script is passed an argument (5)
			- scripts in rc5.d dir are executed 
				- K big to small 
				- S small to big
			
	}}} #
	{{{ #How to Make/Delete a service
		1. 	{{{ #Make service script (yeet.sh)
				```O
				#!/bin/bash
				### BEGIN INIT INFO 
				# Provides:				yeet
				# Required-Start:
				# Required-Stop:
				# Default-Start:		2
				# Default-Stop:	
				# Short-Description:	asdf
				# Description:			asdf
				### END INIT INFO 
				
				case "$1" in
					start)
						echo -n "Starting Yeet Service"
						/usr/bin/yeet
						;;
					stop)
						echo -n Stopping Yeet Service"
						kill `cat /var/run/yeet.pid`
						;;
					*)
						echo "Usage: start|stop
						exit 1
						;;
				esac
				```C
				
			}}} #
		2. Make Service script executable 
			$chmod +x yeet.sh
		2. Move yeet.sh into init 
			$ mv /tmp/yeet.sh /etc/init.d/yeet.sh #(Now is a servce that can be accessed via $ service yeet.sh start)
		3. Enable Service  
			$ update-rc.d yeet.sh 
			- or -
			$ ln -s /etc/init.d/yeet.sh /etc/rc5.d/S08yeet 
	   
	}}} #
	{{{ #How to Make/Delete a job
		$ vim /etc/inittab # yee:234:command:/etc/init.d/yeet.sh 
		- https://www.ibm.com/docs/en/zos/2.2.0?topic=etcinittab-format-file
	
	}}} #
	{{{ #Runlevel Table
		Runlevel	| Purpose (Linux)				
		---			| ---							
		0			| System Shutdown				
		1 (S)		| Single-User Mode				
		2			| Multi-User Mode Non-Networked	
		3			| Multi-User Mode Networked		
		4			| Extra/Unused					
		5			| GUI Mode 						
		6			| Reboot			
	
	}}} #
	{{{ #Fun Facts
		- K scripts don't run on boot (...generally)
		- K scripts don't run if the service isn't running
		- S scripts won't run if the service is already running
		- dependencies are annotated in /etc/init.d/.depend.start (.boot .stop)
		- First userspace process with PID 1
		- inittab keywords
			> wait: tells init to wait for the program to finish executing before going to next line 
			> respawn: tells init to continually monitor the process, and respawn a new copy if the program ever terminates.
			> initdefault:
			> sysinit:
				- sysinit line will be started and finished executing before moving to next line.
				- sysinit lines ONLY run at boot. (not at runlevel changes)
				- first script executed is the rc.sysinit script
	}}} #

}}} ###
{{{ ###Upstart
	{{{ #Important Dirs 
		> init | event.d: Hosts event .conf files
			- Locations:[ubuntu 14 /etc/init/]		
	}}} #
	{{{ #Important Files

	}}} #
	{{{ #Process
		1. .conf files in init dir are executed based on events (events are defined in the .conf files)
		1.5 One of the .conf files kicks off /etc/rc[1-6].d/ scripts (S=Low to High, K=Low to High) 
			
	}}} #
	{{{ #How to Make/Delete an Upstart SysV service
		- Copy the skeleton for format 
			$ cp /etc/init.d/skeleton /etc/init.d/yeet_hostname
		- Edit the do_start() function to do what you want
			- all other lines in the function can be commented out
			- comment out all of do_stop() and do_reload()
		$ chmod 755 /etc/init.d/yeet_hostname 
		- Verify service exists 
			$ service --status-all
		- Start service 
			$ service yeet_hostname start 
		- update runlevel configs 
			$ update-rc.d yeet_hostname start 88 2 3 4 5 
			$ update-rc.d yeet_hostname start 88 2 3 4 5 . stop 0 1 6 #If you have the stop function configured 
			
		- remove service
			$ rm /etc/init.d/yeet_hostname 
			$ update-rc.d yeet_hostname remove 

	}}} #
	{{{ #How to Make/Delete an Upstart service
		- https://zohaib.me/how-to-reliably-start-a-service-with-upstart/
		1. {{{ #Make Service Script (/etc/init/yeet.conf)
			```O
			start on runlevel [2345]
			
			script
				exec /opt/yeet-cannon.sh
			end script
			
			# Respawn and stop respawning if it got respawned 10 times in 10 seconds 
			respawn limit 10 10 
			
			```C
		}}} #
		2. Verify script syntax
			$ init-checkconf /etc/init/yeet.conf 
		3. Reload init configs 
			$ initctl reload-configuration
		4. Verify service exists 
			$ initctl list | grep yeet 
		5. Start service
			$ initctl start yeet 
			
		1. Remove Service 
			$ initctl stop yeet
			$ rm /etc/init/yeet.ssh.conf 
			$ initctl reload-configuration
			$ initctl list
	
	}}} #
	{{{ #How to Make a job
		1. {{{ #Make service script (yeet.conf)
			```O
			description		"Yeet Service"
			author			"CoolHandSquid Penetrations"
			
			start on runlevel [235] or starting gdm or startup 
			stop on runlevel [06]
			
			task 
			exec hostname -b -F /opt/betterhostname	
			```C
			}}} #
		2. .conf file will be read at next runlevel change 
	
	}}} #
	{{{ #Runlevel Table 
		Runlevel	| Purpose (Linux)				
		---			| ---							
		0			| System Shutdown				
		1 (S)		| Single-User Mode				
		2			| Multi-User Mode Non-Networked	
		3			| Multi-User Mode Networked		
		4			| Extra/Unused					
		5			| GUI Mode 						
		6			| Reboot			
	
	}}} #
	{{{ #Fun Facts
		- /sbin/init starts with pid 1
		- Find most likley upstart config directory 
			$ find / -name "*.conf" | xargs -I{} dirname {} | sort | uniq -c | sort -n | tail -n 5 
		- Services are controlled by either initctl or service. 
		- One of the .conf files is used to kick off /etc/rc.d/rcX.d/ scripts (for starting and killing)

}}} #

}}} ###
{{{ ###System D 
	{{{ #Important Dirs 
		- Unit File Directories (If there is a discrepincey, /etc/ trumps.
			> /usr/lib/systemd/system/ or  /lib/systemd/system/:	#Standard Unit File dirs 
			> /etc/systemd/system/:									#Local Unit Files
			> /run/systemd/system/:									#Transient Unit Files
		- Dependencies
			- Wants (Will try to be started)
				> xxx.target.wants: Things that will be try to be started with xxx.target
					- not always target
					- contents are links to unit files
					- Added via 
						$ systemctl add-wants multi-user.target vmtoolsd.service 
						- or - 
						$ ln -s /usr/lib/systemd/system/vmtoolsd.service /usr/lib/systemd/system/multi-user.target.wants/vmtoolsd.service 
						- or -
						- In the [Install] section of the unit file, add the line:
							$ WantedBy=multi-user.target 
						- And then enable the service (making systemd go throught the Install process)
							$ systemctl enable vmtoolsd.service 
			- Requires (Needs to be running to started to start the service)
				- See Wants 
				
	}}} #
	{{{ #Important Files
		> default.target: (/etc/systemd/system/default.target) Defines default target at boot.
		> xxx.conf: (/etc/systemd/system/*unit-file*.d/xxx.conf)
		> rc.local: (/etc/rc.d/rc.local) If executable, it will be run (for sysv compatability)
		
	}}} #
	{{{ #Process
		1. init reads the default.target link
		2. the default.target unit file is read and executed 
		3. links in the default.target.wants file are read queued and executed (order is handeled by sysd)
			
	}}} #
	{{{ #How to Make a SysD SysV service
		- create service shell script in /etc/rc.d/init.d/yeet
		- create soft link to it under prefered runlevels (/etc/rc.d/rc3.d/yeet)
		- Will be ran at next runlevel 
		- NOTE: you can use rc.local if you make it executable.
		- !!SystemV does not actually run on a SystemD system. 
			- If a SysV script is in a SysV place and called upon with `service`, 
				- a unit file is created on the fly out of the .sh file 
					- and is then ran as a SystemD Service 
	   
	}}} #
	{{{ #How to Make a SysD service
		1. add a unit file to /usr/lib/systemd/system/yeet.service 
			- bare minimum 
				```O
				[Service]
				ExecStart=/opt/yeetscript -stfu
				```C
			- To make service enableable (when enabled this will create a symlink to /etc/systemd/system/multi-user.target.wants/)
				```O
				[Install]
				WantedBy=multi-user.target
				```C
		2. Reload Daemons 
			$ systemctl daemon-reload
		3. Enable service (to run [Install] sequence)
			$ systemtl enable yeet.service 
		4. Start service
			$ systemctl start yeet.service 
		
	}}} #
	{{{ #How to Make a SysD job
		$ chmod +x rc.local 
		- Add line in rc.local 
	
	}}} #
	{{{ #Dependencies
		Option		| Meaning
		---			| ---
		Wants		| Should be CoActivated If Possible
		Requires	| Failure of a Requires to start results in service termination
		BindsTo		| Similar to Requires (But Stricter??)
		PartOf		| Similar to Requires, but affects only starting and stopping
		Conflicts	| Cannot be CoActivated with these units 
		
		- Get Dependencies 
			$ systemctl list-dependencies sshd --no-pager
			$ systemctl list-dependencies multi-user.target --no-pager 
		- Get Depends Ons (Things that depend on the service to start 
			$ systemctl list-dependencies sshd --reverse 
		- Add Dependency
			$ systemctl add-requi... 	#TODO:Finish this and add the Remove version
		- Add Wants 
			$ systemctl add-wants multi-user.target vmtoolsd.service 
			$ ln -s /usr/lib/systemd/systemvmtoolsd.service /usr/lib/systemd/system/multi-user.target.wants/vmtoolsd.service 
	
	}}} #
	{{{ #Unit States
		> Load: reflects whether the unit definition was properly loaded
			- Get all unit files and statuses
				$ systemctl list-unit-files 
				$ systemctl list-units --all
			- Load States 
				> Enabled: Will be started at boot time. (enabled through symlink in a *.wants/ directory)
				> Disabled: Will not be started at boot time. (Can be manually started)(Symlink within /etc/systemd/system does not exist)
				> Static: Cannot be enabled, but may be started by an enabled unit automatically. Has no previsions to enable it in the intall section.
		> Active: High level unit activation state
			- Get all active units (that systemd knows about)(attempted to load)
				$ systemctl list-units 
			- Get all AVAILABLE unit files (that systemd knows about)
				$ systemctl list-unit-files 
			- Active Statuses
				> active: Unit is running or has ran 
				> inactive: Not active or running (Potentially failed to start)
		> SUB: Low level unit activation state 
			- Get subactivation states of systemd units 
				$ systemctl list-units 
			- SUB Statuses 
				> running: Running with one or more continuing processes
				> exited: Successfully executed a process then exited.  
				> waiting: Running, But waiting for an event to occur.
				> dead: Not running. (Potentially failed to start)
				> plugged: Device is already working.
	
	}}} #
	{{{ #OverRide Files
			- Used to manipulate someone elses service. 
			- Implemented so local edits survive servce updates
			- View used override files 
				$ systemd-delta 
			- If multiple entries of a value can exist, the override is just appended to a list 
				- something like "ExecStart= " will clear the list 
			- Creating an override.conf file (does not need to be named override, but does need to be named .conf)
				- (1 or 2)
				1. 
					$ vim /etc/systemd/system/nginx.service.d/override.conf 
						```O
						[ Service ]
						ExecStart= 
						ExecStart=/usr/sbin/nginx -c /usr/local/www/nginx.conf 
						```C
					$ systemctl daemon-reload
					$ systemctl restart nginx.service 
				2. 
					$ systemctl edit nginx.service #Which creates and opens the override.conf file 
						```O
						[ Service ]
						ExecStart= 
						ExecStart=/usr/sbin/nginx -c /usr/local/www/nginx.conf 
						```C
					$ systemctl restart nginx.servce
	
	}}} #
	{{{ #Target Table
		Runlevel| Target 
		---		| ---
		0		| poweroff.target 
		1		| rescure.target 
		2		| multi-user.target
		3		| multi-user.target
		4		| multi-user.target
		5		| graphical.target
		6		| reboot.target 
		
		- target "levels" order 
		- local-fs-pre.target 
		- local-fs.target
		- sysinit.target
		- basic.target		
		- multi-user.target	(similar to runlevel 3)
		- graphical.target  (similar to runlevel 5)
		
	}}} #
	{{{ #Fun Facts
		- pid 1 is /usr/lib/systemd/systemd or /sbin/init (actually a Slink to /usr/lib/systemd/systemd)
		- execution order is handled by systemd 
		- For good unit file info: man systemd.target, systemd.service...
				
	}}} #
	
}}} ###
{{{ ###SMF  
	{{{ #Important Dirs 
		> Manifest xml categories: /var/svc/manifest
		> Profile: /var/svc/profile	#Determines wether the instance is enabled or disabled (allegedly)
		
	}}} #
	{{{ #Important Files
		> repository.db: /etc/svc/repository.db	#Persistant service configuration database

	}}} #
	{{{ #Process
		1. kernel scans /etc/system for loadable kernel modules
		2. init starts svc.startd (respawning manager) and svc.configd (repository.db manager)
			
	}}} #
	{{{ #How to Make/Delete a SMF SysV service
	
	}}} #
	{{{ #How to Make/Delete a SMF service
		1. Pray you don't have to 
		2. http://uadmin.nl/init/exercise-add-smf-service/
	   
	}}} #
	{{{ #How to Make/Delete a job

	}}} #
	{{{ #Milestone Table
		Milestone			| Runlevel
		---					| ---
		none				| N/A
		single-user			| S
		multi-user 			| 2
		Multi-User-server 	| 3
		all					| 3

		Milestones
		1. Devices
		2. Sysconfig
		3. Network
		4. Name-Services 
		5. Single-User 
		6. Multi-User
		7. Multi-User Server 
	
	}}} #
	{{{ #Fun Facts
		- /sbin/init	= OpenSolaris/Solaris 10
		- /etc/init		= Old Solaris

		FMRI States Table
		State		| Description
		---			| ---
		online		| enabled and succesfully started
		disabled	| not enabled and not running
		degraded	| enabled but running with limitations
		legacy_run	| running in sysv format
		uninitalized| starting up
		maintenence	| error requiring admin has occured
		offline		| enabled but offline (often an unsatisfied dependency)
		
	}}} #

}}} ###

